<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ARP</title>
<style>
:root {
  --verde: #064420;
  --blu: #0a4d68;
  --chiaro: #f0f8f8;
  --bianco: #fff;
  --ombra: rgba(0, 0, 0, 0.15);
  --raggio: 16px;
}
/* Make sizing predictable and images/tables responsive */
*, *::before, *::after { box-sizing: border-box; }
img, video, svg { max-width: 100%; height: auto; display: block; }

/* Prevent horizontal overflow: allow inner sections to scroll when needed */
.app-wrapper { margin: 0.6rem auto; box-sizing: border-box; }
.calendar-card { overflow-x: auto; -webkit-overflow-scrolling: touch; }
.calendar-table { min-width: 680px; }

/* Allow nav to scroll horizontally on small widths */
.nav { -webkit-overflow-scrolling: touch; }

/* Visual highlight for calendar updates */
.cell-updated {
  animation: calendar-flash 0.9s ease;
}
@keyframes calendar-flash {
  0% { background: #e6f9f4; }
  50% { background: #d7f3ea; }
  100% { background: var(--chiaro); }
}
html, body {
  height: 100%;
  margin: 0;
  font-family: "Segoe UI", Arial, sans-serif;
  background: linear-gradient(135deg, var(--verde) 20%, var(--blu) 80%);
  display: flex;
  align-items: flex-start;
  justify-content: center;
  color: #222;
  overflow: auto;
  min-height: 100vh;
}
.app-wrapper {
  width: 98%;
  max-width: 1500px;
  height: 93vh;
  background: var(--bianco);
  border-radius: var(--raggio);
  display: grid;
  grid-template-columns: 220px 2.1fr 390px;
  box-shadow: 0 10px 30px var(--ombra);
  overflow: hidden;
}
.sidebar {
  background: linear-gradient(to bottom, var(--verde), var(--blu));
  color: var(--bianco);
  padding: 1.5rem 1rem;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}
.sidebar h2 {
  font-size: 1.3rem;
  margin: 0 0 1.5rem;
  text-align: center;
}
.nav {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.nav button {
  background: transparent;
  color: var(--bianco);
  border: none;
  padding: 0.8rem;
  text-align: left;
  border-radius: 10px;
  cursor: pointer;
  transition: 0.2s;
}
.nav button.active, .nav button:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: translateX(4px);
}
main {
  background: var(--chiaro);
  padding: 2.1rem 0 2rem 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.content-scroll {
  flex: 1;
  overflow-y: auto;
  scroll-behavior: smooth;
}
.screen {
  display: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  padding: 32px 36px;
}
.screen.active {
  display: block;
  padding: 32px 36px;
}


.card {
  background: var(--bianco);
  border-radius: var(--raggio);
  padding: 1.2rem 2.2rem;
  box-shadow: 0 2px 8px var(--ombra);
  margin-bottom: 1.4rem;
}
.card h3 {
  color: var(--blu);
  margin-top: 0;
  letter-spacing: 0.03em;
}
.routine-card {
  box-shadow: 0 6px 24px rgba(10,77,104,0.13);
  background: var(--bianco);
  border-radius: var(--raggio);
  padding: 1.3rem 2rem;
  max-width: 450px;
  margin: 0 auto;
}
.routine-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.routine-list li {
  display: flex;
  align-items: center;
  padding: 0.75rem 0;
  border-bottom: 1px solid #e0e6ed;
  transition: background 0.18s;
  gap: 1.3rem;
}
.routine-list li:last-child { border-bottom: none; }
.routine-list li:hover { background: #f0f8f8; border-radius: 7px; }
.routine-time {
  font-weight: 600;
  color: var(--verde);
  font-family: monospace;
  flex-shrink: 0;
  font-size: 1.08em;
  opacity: 0.89;
}
.routine-icon {
  font-size: 1.31em;
  margin: 0 8px;
  flex-shrink: 0;
  filter: saturate(1.3);
}
.routine-task {
  font-size: 1em;
  color: var(--blu);
  min-width: 0;
  flex-grow: 1;
  word-break: break-word;
}
/* Chat */
.chat {
  display: flex;
  flex-direction: column;
  height: 100%;
  border-left: 1px solid #ddd;
  background: #f9f9f9;
  min-height: 0;
}
.chat-header {
  background: linear-gradient(to right, var(--verde), var(--blu));
  color: var(--bianco);
  padding: 1rem;
  font-weight: 600;
  text-align: center;
  flex-shrink: 0;
  font-size: 1.12rem;
}
.chat-messages {
  flex: 1;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  overflow-y: auto;
  background: #fafafa;
  scroll-behavior: smooth;
}
.message {
  max-width: 82%;
  padding: 0.7rem 1rem;
  border-radius: var(--raggio);
  box-shadow: 0 2px 6px var(--ombra);
  line-height: 1.44;
  word-wrap: break-word;
}
.message.AI {
  align-self: flex-start;
  background: var(--blu);
  color: var(--bianco);
  border-bottom-left-radius: 0;
}
.message.Utente {
  align-self: flex-end;
  background: var(--verde);
  color: var(--bianco);
  border-bottom-right-radius: 0;
}
.message.AI.typing {
  font-style: italic;
  position: relative;
}
.message.AI.typing::after {
  content: "...";
  animation: blink 1.4s infinite;
  margin-left: 4px;
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}
.chat-footer {
  padding: 1rem;
  border-top: 1px solid #ddd;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
  background: var(--bianco);
}
.suggestions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}
.suggestions button {
  background: #e8f2f1;
  border: none;
  border-radius: 12px;
  padding: 0.4rem 0.8rem;
  cursor: pointer;
  color: var(--blu);
  font-size: .98em;
  font-weight: 500;
}
.suggestions button:hover {
  background: var(--blu);
  color: var(--bianco);
}
.input-row {
  display: flex;
  gap: 0.6rem;
  align-items: center;
}
input {
  flex: 1;
  padding: 0.7rem 1rem;
  border: 1px solid #ccc;
  border-radius: 12px;
  outline: none;
}
button.send {
  background: linear-gradient(135deg, var(--verde), var(--blu));
  color: var(--bianco);
  border: none;
  border-radius: 12px;
  padding: 0.8rem 1.1rem;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
}
.switch-page {
  text-align: center;
  margin-top: 1rem;
}
.switch-page button {
  background: #fff;
  color: var(--blu);
  border-radius: 10px;
  padding: 0.5rem 1rem;
  border: none;
  cursor: pointer;
  font-size: 1rem;
}
.chat-messages::-webkit-scrollbar {
  width: 8px;
}
.chat-messages::-webkit-scrollbar-thumb {
  background: var(--blu);
  border-radius: 4px;
}

#calendar .card.calendar-card {
  max-width: 800px;
  margin: 0 auto;
  padding: 1.5rem 2.5rem;
  background: var(--bianco);
  border-radius: var(--raggio);
  box-shadow: 0 8px 32px rgba(10,77,104,0.14);
  transition: box-shadow 0.3s ease;
}
#calendar .card.calendar-card:hover {
  box-shadow: 0 12px 48px rgba(10,77,104,0.25);
}
#calendar .calendar-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 8px 12px;
  background: transparent;
  table-layout: auto;
}
#calendar .calendar-table thead tr th {
  background: var(--verde);
  border-radius: 8px;
  color: var(--bianco);
  padding: 14px 10px;
  font-weight: 700;
  letter-spacing: 0.04em;
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.07);
}
#calendar .calendar-table tbody tr td {
  background: var(--chiaro);
  border: none;
  padding: 16px 10px;
  font-size: 0.95rem;
  text-align: center;
  vertical-align: top;
  border-radius: 12px;
  box-shadow: 0 4px 14px var(--ombra);
  cursor: default;
  transition: background 0.3s ease;
  word-wrap: break-word;
  min-height: 70px;
}
#calendar .calendar-table tbody tr td:hover {
  background: #e6f3f1;
}
#calendar .calendar-event {
  display: block;
  max-width: 100%;

  word-wrap: break-word;
  overflow-wrap: break-word;
  word-break: break-word;
}

#calendar .calendar-event:hover {
  background-color: #005f8a;
}
#calendar .calendar-table tbody tr:nth-child(even) td {
  background: #f9fdfc;
}


.card ul {
  list-style: none;
  padding-left: 0;
}
.integration-item {
  background: #e8f2f1;
  border-radius: 12px;
  padding: 0.8rem 1rem;
  margin: 0.5rem 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--blu);
  cursor: pointer;
  transition: background 0.22s;
  font-size: 1rem;
}
.integration-item:hover {
  background: var(--blu);
  color: var(--bianco);
}
.integration-status {
  font-size: 1.23rem;
}
button.add-service {
  margin-top: 1rem;
  background: linear-gradient(135deg, var(--verde), var(--blu));
  color: var(--bianco);
  border: none;
  border-radius: 12px;
  padding: 0.7rem 1.1rem;
  cursor: pointer;
  font-weight: 500;
}
button.add-service:hover {
  background: var(--verde);
}
/* Responsive: tablet and mobile adjustments */
@media (max-width: 1024px) {
  html, body {
    align-items: flex-start;
    overflow: auto;
  }
  .app-wrapper {
    width: 100%;
    max-width: 100%;
    height: auto;
    display: grid;
    grid-template-columns: 1fr;
    grid-auto-rows: auto;
    gap: 0.6rem;
    padding: 0.6rem;
    box-shadow: none;
  }
  .sidebar {
    flex-direction: row;
    align-items: center;
    padding: 0.6rem;
    border-radius: 12px;
  }
  .nav {
    flex-direction: row;
    gap: 0.5rem;
    overflow-x: auto;
    padding-bottom: 0.25rem;
  }
  .nav button {
    white-space: nowrap;
    padding: 0.45rem 0.6rem;
    font-size: 0.95rem;
  }
  main {
    padding: 1rem 0.6rem 0.6rem 0.6rem;
  }
  .content-scroll { max-height: none; }
  .screen, .screen.active { padding: 16px; }
  .card { padding: 0.8rem 1rem; margin-bottom: 0.9rem; }
  .routine-card { max-width: 100%; margin: 0; }
  .chat { border-left: none; border-top: 1px solid #e6e6e6; }
  .chat-header { font-size: 1rem; padding: 0.7rem; }
  .chat-messages { padding: 0.6rem; }
  .chat-footer { padding: 0.65rem; }
  .calendar-table thead tr th, .calendar-table tbody tr td { padding: 8px 6px; font-size: 0.85rem; }
}
@media (max-width: 480px) {
  :root { --raggio: 12px; }
  .sidebar h2 { font-size: 1rem; }
  .app-wrapper { padding: 0.4rem; }
  .nav button { padding: 0.35rem 0.5rem; font-size: 0.9rem; }
  .card h3 { font-size: 1rem; }
  .chat-messages .message { max-width: 100%; }
  input { padding: 0.6rem; }
  .suggestions button { padding: 0.35rem 0.6rem; font-size: 0.9rem; }

}

/* Keep the centered desktop layout for large screens */
@media (min-width: 1025px) {
  html, body {
    align-items: center;
    overflow: hidden;
  }
  .app-wrapper {
    height: 93vh;
    box-shadow: 0 10px 30px var(--ombra);
  }
}
</style>
</head>
<body>
<!-- Pagina Base -->
<div class="app-wrapper" id="userPage">
  <aside class="sidebar">
    <div>
      <h2>ARP</h2>
      <nav class="nav" id="userNav">
        <button class="active" data-screen="dashboard">üè† Dashboard</button>
        <button data-screen="calendar">üìÖ Calendario</button>
        <button data-screen="routine">üß† Routine</button>
        <button data-screen="groups">üë• Gruppi</button>
        <button data-screen="integrations">üîó Integrazioni</button>
      </nav>
    </div>
    <div class="switch-page">
      <button id="toDev">Modalit√† Developer</button>
    </div>
  </aside>
  <main>
    <div class="content-scroll">
      <section id="dashboard" class="screen active">
        <div class="card">
          <h3>üìä Panoramica giornaliera</h3>
          <p>3 attivit√† completate su 5. Oggi: riunione, allenamento, spesa.</p>
        </div>
        <div class="card">
          <h3>üîî Promemoria</h3>
          <p>Pagamento bolletta domani.</p>
        </div>
      </section>
      <section id="calendar" class="screen">
          <div class="card calendar-card">
            <h3>üìÖ Calendario settimanale</h3>
            <table class="calendar-table" aria-label="Calendario settimanale">
              <thead>
                <tr>
                  <th>Luned√¨</th>
                  <th>Marted√¨</th>
                  <th>Mercoled√¨</th>
                  <th>Gioved√¨</th>
                  <th>Venerd√¨</th>
                  <th>Sabato</th>
                  <th>Domenica</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td data-day="lunedi"></td>
                  <td data-day="martedi"></td>
                  <td data-day="mercoledi"></td>
                  <td data-day="giovedi"></td>
                  <td data-day="venerdi"></td>
                  <td data-day="sabato"></td>
                  <td data-day="domenica"></td>
                </tr>
                <tr>
                  <td colspan="7" style="font-style: italic; font-size: 0.89rem; text-align:center; color:#555;">Eventi per la settimana visualizzati giorno per giorno</td>
                </tr>
              </tbody>
            </table>
          </div>
      </section>
      <section id="routine" class="screen">
        <div class="card routine-card">
          <h3>La tua routine di oggi!</h3>
          <ul class="routine-list">
            <li>
              <span class="routine-time">07:00 - 07:15</span>
              <span class="routine-icon">üßò</span>
              <span class="routine-task">Meditazione</span>
            </li>
            <li>
              <span class="routine-time">08:00 - 17:00</span>
              <span class="routine-icon">‚ö°</span>
              <span class="routine-task">Lavoro</span>
            </li>
            <li>
              <span class="routine-time">17:30 - 19:00</span>
              <span class="routine-icon">üèÉ‚Äç‚ôÇÔ∏è</span>
              <span class="routine-task">Allenamento in palestra</span>
            </li>
          </ul>
        </div>
      </section>
      <section id="groups" class="screen">
        <div class="card">
          <h3>Gruppo Famiglia</h3>
          <p>Oggi nessun membro sar√† a casa prima delle 17:00</p>
          <p>Tutti sono liberi sabato - suggerisco di organizzare un pranzo insieme üçù</p>
        </div>
        <div class="card">
          <h3>‚ûï Crea nuovo gruppo</h3>
          <p>Puoi aggiungere membri, impostare eventi e sincronizzare calendari condivisi.</p>
        </div>
      </section>
      <section id="integrations" class="screen">
        <div class="card">
          <h3>Integrazioni attive</h3>
          <ul id="integrationList" aria-live="polite"></ul>
          <button class="add-service" id="addIntegrationBtn" aria-label="Aggiungi nuovo servizio">‚ûï Aggiungi servizio</button>
        </div>
      </section>
    </div>
  </main>
  <section class="chat" aria-live="polite" aria-atomic="false">
    <div class="chat-header">Assistente Personale</div>
    <div class="chat-messages" id="messages"></div>
    <div class="chat-footer">
      <div class="suggestions" id="suggestions" role="list">
        <button data-msg="mostrami il calendario" role="listitem" aria-label="Mostrami il calendario">calendario</button>
        <button data-msg="come migliorare la routine" role="listitem" aria-label="Come migliorare la routine">routine</button>
        <button data-msg="eventi in famiglia" role="listitem" aria-label="Eventi in famiglia">famiglia</button>
      </div>
      <div class="input-row">
        <input id="userInput" type="text" placeholder="Scrivi o tocca un suggerimento..." aria-label="Input messaggio" />
        <button class="send" id="sendBtn" aria-label="Invia messaggio" disabled>Invia</button>
      </div>
    </div>
  </section>
</div>
<div class="app-wrapper" id="devPage" style="display:none;">
  <aside class="sidebar">
    <div>
      <h2>Developer Hub</h2>
      <nav class="nav" id="devNav">
        <button class="active" data-screen="overview">üèó Overview</button>
        <button data-screen="github">üêô GitHub</button>
        <button data-screen="api">üîå API</button>
        <button data-screen="groupsDev">üë• Team</button>
        <button data-screen="integrationsDev">üîó Integrazioni</button>
      </nav>
    </div>
    <div class="switch-page">
      <button id="toUser">Modalit√† Base</button>
    </div>
  </aside>
  <main>
    <div class="content-scroll">
      <section id="overview" class="screen active">
        <div class="card">
          <h3>üì¶ Build Status</h3>
          <p>Ultima build completata alle 09:12 ‚úÖ</p>
        </div>
        <div class="card">
          <h3>‚öôÔ∏è Ambiente</h3>
          <p>Node v20, Next.js 15, Database connesso.</p>
        </div>
      </section>
      <section id="github" class="screen">
        <div class="card">
          <h3>üêô Repo principale</h3>
          <p>Branch: <b>main</b> ¬∑ Pull Request aperte: 2 ¬∑ Issue: 3</p>
        </div>
      </section>
      <section id="api" class="screen">
        <div class="card">
          <h3>üîå Monitor API</h3>
          <p>Latency media: 120ms ¬∑ Status: OK ¬∑ Endpoint attivi: /login, /sync, /groups</p>
        </div>
      </section>
      <section id="groupsDev" class="screen">
        <div class="card">
          <h3>üë®‚Äçüíª Team Progetto Pagina Web</h3>
          <ul>
            <li>Anna ‚Äì UI/UX</li>
            <li>Marco ‚Äì Backend</li>
            <li>Sara ‚Äì Frontend</li>
          </ul>
          <p>Task: <b>Homepage responsive</b> in progress, <b>API Auth</b> completata</p>
        </div>
        <div class="card">
          <h3>‚ûï Crea nuovo team</h3>
          <p>Assegna ruoli, task e integrazioni GitHub automatiche.</p>
        </div>
      </section>
      <section id="integrationsDev" class="screen">
        <div class="card">
            <h3>Integrazioni</h3>
            <ul id="integrationListDev" aria-live="polite"></ul>
            <button class="add-service" id="addIntegrationBtnDev" aria-label="Aggiungi nuovo servizio">‚ûï Aggiungi servizio</button>
        </div>
        </section>

    </div>
  </main>
  <section class="chat">
    <div class="chat-header">Developer Assistance</div>
    <div class="chat-messages" id="messagesDev"></div>
    <div class="chat-footer">
      <div class="suggestions" id="suggestionsDev">
        <button data-msg="stato build">üèó build</button>
        <button data-msg="api attive">üîå api</button>
        <button data-msg="team progetto">üë• team</button>
      </div>
      <div class="input-row">
        <input id="devInput" type="text" placeholder="Scrivi o tocca un suggerimento..." />
        <button class="send" id="devSendBtn">Invia</button>
      </div>
    </div>
  </section>
</div>
<script>
    // Global chat & calendar context
    window.chatContext = { awaitingEvent: false };
    window.calendarEvents = {
      lunedi: [{name: 'Lavoro remoto', time: '08:00'}],
      martedi: [{name: 'Riunione', time: '10:00'}],
      mercoledi: [],
      giovedi: [],
      venerdi: [],
      sabato: [{name: 'libero (tutti disponibili per pranzo!)', time: null}],
      domenica: []
    };

    // NEW: Define routine with time ranges
    window.dailyRoutine = [
      { name: 'Meditazione', start: '07:00', end: '07:15', icon: 'üßò', keywords: ['meditazione', 'yoga', 'respiro', 'mindfulness'] },
      { name: 'Lavoro', start: '08:00', end: '17:00', icon: '‚ö°', keywords: ['lavoro', 'meeting', 'riunione', 'call', 'progetto', 'task', 'ufficio', 'cliente'] },
      { name: 'Allenamento in palestra', start: '17:30', end: '19:00', icon: 'üèÉ‚Äç‚ôÇÔ∏è', keywords: ['allenamento', 'palestra', 'sport', 'corsa', 'fitness', 'gym'] }
    ];

    const DAY_DISPLAY = {
      lunedi: 'Luned√¨',
      martedi: 'Marted√¨',
      mercoledi: 'Mercoled√¨',
      giovedi: 'Gioved√¨',
      venerdi: 'Venerd√¨',
      sabato: 'Sabato',
      domenica: 'Domenica'
    };

    // NEW: Check if event is compatible with routine (based on keywords)
    function isEventCompatibleWithRoutine(eventName, routine) {
      if (!eventName || !routine || !routine.keywords) return false;
      
      const normalized = eventName.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu, '');
      
      // Check if any routine keyword is present in event name
      return routine.keywords.some(keyword => normalized.includes(keyword));
    }

    // NEW: Check if a time conflicts with routine
    function checkRoutineConflict(time, eventName = null, dayOfWeek = null) {
      if (!time) return null;
      
      const eventTime = time.split(':').map(Number);
      const eventMinutes = eventTime[0] * 60 + eventTime[1];
      
      for (const routine of window.dailyRoutine) {
        // NEW: Skip work routine on weekends
        if (routine.name === 'Lavoro' && dayOfWeek && (dayOfWeek === 'sabato' || dayOfWeek === 'domenica')) {
          continue; // Skip this routine for weekends
        }
        
        const startTime = routine.start.split(':').map(Number);
        const endTime = routine.end.split(':').map(Number);
        const startMinutes = startTime[0] * 60 + startTime[1];
        const endMinutes = endTime[0] * 60 + endTime[1];
        
        // Check if event time falls within routine time range
        if (eventMinutes >= startMinutes && eventMinutes < endMinutes) {
          // Check if event is compatible with this routine
          if (eventName && isEventCompatibleWithRoutine(eventName, routine)) {
            return null; // No conflict - event is compatible
          }
          return routine;
        }
      }
      
      return null;
    }

    // NEW: Suggest alternative times avoiding routine conflicts
    function suggestAlternativeTime(originalTime) {
      const suggestions = [];
      
      // Find free slots between and around routine blocks
      const slots = [
        { start: '06:00', end: '07:00', label: 'prima mattina' },
        { start: '07:15', end: '08:00', label: 'dopo meditazione' },
        { start: '19:00', end: '22:00', label: 'sera dopo allenamento' },
        { start: '12:00', end: '13:00', label: 'pausa pranzo' }
      ];
      
      for (const slot of slots) {
        const conflict = checkRoutineConflict(slot.start);
        if (!conflict) {
          suggestions.push({ time: slot.start, label: slot.label });
        }
      }
      
      return suggestions.slice(0, 3); // Return top 3 suggestions
    }

    // NEW: Format time conflict message
    function formatConflictMessage(conflictingRoutine, eventName, alternativeTimes) {
      const alternatives = alternativeTimes.map(alt => 
        `${alt.time} (${alt.label})`
      ).join(', ');
      
      return `‚ö†Ô∏è Attenzione! "${eventName}" alle ${window.chatContext.conflictTime} √® in conflitto con "${conflictingRoutine.name}" (${conflictingRoutine.start}-${conflictingRoutine.end}). Ti suggerisco questi orari alternativi: ${alternatives}. Quale preferisci? (oppure scrivi un altro orario)`;
    }

    // Analyze calendar and suggest best days
    function suggestAvailableDays() {
      const availability = [];
      Object.keys(window.calendarEvents).forEach(day => {
        const events = window.calendarEvents[day];
        const count = events.length;
        availability.push({ day, count, display: DAY_DISPLAY[day] });
      });
      // Sort by least busy
      availability.sort((a, b) => a.count - b.count);
      return availability;
    }

    function formatDaySuggestions(availability) {
      const top3 = availability.slice(0, 3);
      const suggestions = top3.map(a => {
        const status = a.count === 0 ? 'completamente libero' : `${a.count} impegno/i`;
        return `${a.display} (${status})`;
      });
      return suggestions.join(', ');
    }

    // Sort events by time within each day
    function sortEventsByTime(events) {
      return events.sort((a, b) => {
        if (!a.time) return 1;
        if (!b.time) return -1;
        return a.time.localeCompare(b.time);
      });
    }

    function renderCalendar() {
      Object.keys(window.calendarEvents).forEach(day => {
        const cell = document.querySelector(`#calendar td[data-day="${day}"]`);
        if (!cell) return;
        const items = window.calendarEvents[day];
        cell.innerHTML = items.map(event => {
          const displayText = event.time ? `${event.time} - ${event.name}` : event.name;
          return `<div class="calendar-event" title="${displayText}">${displayText}</div>`;
        }).join('');
      });
    }

    // Updated to handle time
    function addCalendarEvent(name, dayNormalized, time = null) {
      if (!dayNormalized || !window.calendarEvents[dayNormalized]) return false;
      const events = window.calendarEvents[dayNormalized];
      const DEFAULT_SABATO = 'libero (tutti disponibili per pranzo!)';
      
      // If adding to Saturday and the default 'libero' exists, remove it first
      if (dayNormalized === 'sabato') {
        const idx = events.findIndex(e => e.name === DEFAULT_SABATO);
        if (idx !== -1) events.splice(idx, 1);
      }
      
      events.push({ name, time });
      window.calendarEvents[dayNormalized] = sortEventsByTime(events);
      renderCalendar();
      return true;
    }

    // Clean up event name by removing leading articles
    function cleanEventName(text) {
      if (!text) return text;
      // Remove leading articles and trim
      return text.replace(/^(un|una|uno|il|la|lo|l'|i|gli|le)\s+/i, '').trim();
    }

    // Parse time from text (e.g., "alle 14:30", "14:00", "alle 9")
    function parseTime(text) {
      if (!text) return null;
      const normalized = text.toLowerCase().trim();
      
      // Match patterns like "14:30", "alle 14:30", "14", "alle 9"
      const timePatterns = [
        /\b(\d{1,2}):(\d{2})\b/,           // 14:30
        /\balle?\s+(\d{1,2}):(\d{2})\b/,  // alle 14:30
        /\balle?\s+(\d{1,2})\b/,          // alle 14
        /\b(\d{1,2})\s*:\s*(\d{2})\b/     // 14 : 30
      ];
      
      for (const pattern of timePatterns) {
        const match = normalized.match(pattern);
        if (match) {
          const hours = match[1];
          const minutes = match[2] || '00';
          return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;
        }
      }
      
      return null;
    }

    // Parse a user message to extract event name and weekday (basic heuristic)
    function parseEventDetails(text) {
      if (!text) return null;
      // normalize: remove diacritics, lowercase
      const norm = text.normalize ? text.normalize('NFD').replace(/\p{Diacritic}/gu, '') : text;
      let t = String(norm).toLowerCase().trim();
      
      // NEW: Remove trigger words and modal verbs first
      t = t.replace(/\b(aggiungi|aggiung|aggiungere|voglio aggiungere|inserisci|metti|crea evento|crea|vorrei|voglio|dovrei|potrei|posso)\b/g, '').trim();
      
      // Extract time first
      const time = parseTime(t);
      // Remove time from text
      if (time) {
        t = t.replace(/\b(alle?|at)?\s*\d{1,2}\s*:\s*\d{2}\b/g, '')
             .replace(/\balle?\s+\d{1,2}\b/g, '');
      }
      
      // weekday tokens (normalized)
      const days = ['lunedi','luned√¨','martedi','marted√¨','mercoledi','mercoled√¨','giovedi','gioved√¨','venerdi','venerd√¨','sabato','domenica'];
      let found = null;
      for (const d of days) {
        const dn = d.normalize ? d.normalize('NFD').replace(/\p{Diacritic}/gu, '') : d;
        const re = new RegExp('\\b' + dn + '\\b');
        if (re.test(t)) {
          const canonical = Object.keys(DAY_DISPLAY).find(k => dn.indexOf(k.replace(/i$/,'')) !== -1) || dn;
          found = canonical;
          // remove the day word from t to get a candidate name
          t = t.replace(re, '').replace(/\b(il|la|lo|l'|per|di|del|della)\b/g, '').replace(/[:,-]/g, ' ').trim();
          break;
        }
      }
      if (!found) return null;
      
      // Clean up the name
      let name = t.length ? cleanEventName(t) : null;
      // Capitalize first letter
      if (name) {
        name = name.charAt(0).toUpperCase() + name.slice(1);
      }
      
      return { name, day: found, time };
    }

const integrationListDev = document.getElementById('integrationListDev');
const addIntegrationBtnDev = document.getElementById('addIntegrationBtnDev');

let integrationsDev = [
  {name: "GitHub", active: true},
  {name: "Docker", active: false}
];

function renderIntegrationsDev() {
  integrationListDev.innerHTML = '';
  integrationsDev.forEach((service, i) => {
    const li = document.createElement('li');
    li.className = 'integration-item';     // classe condivisa
    li.setAttribute('tabindex', 0);
    li.setAttribute('role', 'button');
    li.setAttribute('aria-pressed', service.active ? 'true' : 'false');
    li.textContent = service.name;
    const status = document.createElement('span');
    status.className = 'integration-status';  // classe condivisa
    status.textContent = service.active ? '‚úÖ' : '‚öôÔ∏è';
    li.appendChild(status);

    li.addEventListener('click', () => {
      integrationsDev[i].active = !integrationsDev[i].active;
      renderIntegrationsDev();
    });
    li.addEventListener('keyup', e => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        li.click();
      }
    });
    integrationListDev.appendChild(li);
  });
}
renderIntegrationsDev();

addIntegrationBtnDev.addEventListener('click', () => {
  const newName = prompt("Inserisci nome del nuovo servizio:");
  if(newName && newName.trim() !== "") {
    integrationsDev.push({name: newName.trim(), active: true});
    renderIntegrationsDev();
  }
});
    
function setupNav(navId, mainId) {
  document.querySelectorAll(`#${navId} button`).forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(`#${navId} button`).forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      document.querySelectorAll(`#${mainId} .screen`).forEach(s => s.classList.remove("active"));
      document.getElementById(btn.dataset.screen).classList.add("active");
    });
  });
}
setupNav("userNav", "userPage");
setupNav("devNav", "devPage");
document.getElementById("toDev").addEventListener("click", () => {
  document.getElementById("userPage").style.display = "none";
  document.getElementById("devPage").style.display = "grid";
});
document.getElementById("toUser").addEventListener("click", () => {
  document.getElementById("devPage").style.display = "none";
  document.getElementById("userPage").style.display = "grid";
});
function setupChat(msgContainerId, inputId, sendId, suggestionsId) {
  const container = document.getElementById(msgContainerId);
  const input = document.getElementById(inputId);
  const sendBtn = document.getElementById(sendId);
  const suggestions = document.getElementById(suggestionsId);
  function canSend() { return input.value.trim().length > 0; }
  input.addEventListener('input', () => { sendBtn.disabled = !canSend(); });
  function appendMessage(msg, author, typing=false) {
    const div = document.createElement("div");
    div.className = "message " + author;
    if (typing) div.classList.add("typing");
    div.textContent = msg;
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
    return div;
  }
  
  
function aiSuggestion(userMsg) {
  if (!userMsg || typeof userMsg !== 'string') {
    return "Al momento non sono capace di aiutarti, ma sto imparando!";
  }
  const normalized = userMsg
    .normalize && userMsg.normalize('NFD').replace(/\p{Diacritic}/gu, '')
    || userMsg;
  const text = String(normalized).toLowerCase().trim();

  const responsesFamiglia = [
    "La famiglia ha un pranzo previsto per sabato, vuoi aggiungerlo al calendario?",
    "Hai deciso se partecipare al pranzo di sabato?"
  ];

  const responsesRoutine = [
    "Ti suggerisco di fare la spesa verso le 18:00, dopo l'allenamento.",
    "Hai gi√† impostato la meditazione ogni mattina alle 7:00.",
    "Per migliorare la routine potresti aggiungere una pausa relax a met√† pomeriggio.",
    "La tua routine √® molto equilibrata, continua cos√¨!"
  ];

  const responsesCalendario = [
    "Marted√¨ alle 10:00 hai una riunione programmata, ti preparo tutto per tempo.",
    "Ho gi√† aggiunto per te un evento importante questa settimana, te lo ricorder√≤ il giorno prima.",
    "Il tuo calendario √® sincronizzato e aggiornato.",
    "Ti terr√≤ aggiornato automaticamente con promemoria per i tuoi eventi importanti."
  ];

  const buildStatusResponses = [
    "üì¶ Lo stato dell'ultima build √® OK: completata con successo alle 09:12 ‚úÖ. Il sistema gira su Node v20 con Next.js 15 e un database connesso."
  ];

  const apiActiveResponses = [
    "üîå Le API attive includono gli endpoint /login, /sync e /groups con una latenza media di 120ms e stato operativo."
  ];

  const teamProjectResponses = [
    "üë®‚Äçüíª Il team di progetto comprende Anna (UI/UX), Marco (Backend) e Sara (Frontend). Attualmente lavorano alla homepage responsive e autenticazione API completata."
  ];

  // Risposte a feedback utente
  if (/\b(va bene|ok|s√¨|si|certo|okay|yes|d'accordo|confermo|grazie)\b/.test(text)) {
    return "Perfetto, fammi sapere se hai bisogno di altro.";
  }
  if (/\b(no|non|nono|assolutamente no|negativo|no grazie)\b/.test(text)) {
    return "Nessun problema, fammi sapere se posso aiutarti con altro.";
  }

  // NEW: Detect when user asks for event scheduling suggestions
  if (/\b(quando posso|quando potrei|quando sono libero|suggerisci un giorno|quando aggiungere|miglior giorno|giorno libero|giorni disponibili)\b/.test(text)) {
    // Extract potential event name from message
    const eventMatch = text.match(/\b(aggiungere|inserire|mettere|programmare)\s+(.+?)(\?|$)/);
    let eventName = eventMatch ? eventMatch[2].trim() : null;
    
    if (eventName) {
      eventName = cleanEventName(eventName);
      eventName = eventName.charAt(0).toUpperCase() + eventName.slice(1);
    }
    
    const availability = suggestAvailableDays();
    const suggestions = formatDaySuggestions(availability);
    
    if (eventName) {
      window.chatContext.awaitingDayConfirmation = true;
      window.chatContext.pendingEventName = eventName;
      return `Per "${eventName}" ti suggerisco: ${suggestions}. Quale giorno preferisci?`;
    } else {
      return `I giorni migliori sono: ${suggestions}. Dimmi quale evento vuoi aggiungere e in che giorno.`;
    }
  }

  if (/\bfamiglia\b|\bparenti\b|\bfesta\b|\bpranzo\b/.test(text)) {
    return responsesFamiglia[Math.floor(Math.random() * responsesFamiglia.length)];
  }
  if (/\broutine\b|\brespiro\b|\bmeditazione\b|\ballenamento\b|\bfocus\b/.test(text)) {
    return responsesRoutine[Math.floor(Math.random() * responsesRoutine.length)];
  }
  if (/\bcalendario\b|\bevento\b|\brigunione\b|\bpromemoria\b/.test(text)) {
    // If user expresses intent to add an event, set awaitingEvent state and ask for details
    if (/\b(aggiungi|aggiung|aggiungere|voglio aggiungere|nuovo impegno|aggiungere un|aggiungo)\b/.test(text)) {
      window.chatContext.awaitingEvent = true;
      return "Perfetto, dimmi il nome dell'evento e il giorno (puoi includere anche l'orario)";
    }
    return responsesCalendario[Math.floor(Math.random() * responsesCalendario.length)];
  }
  if (/\bstato build\b|\bbuild\b|\bstato compilazione\b/.test(text)) {
    return buildStatusResponses[0];
  }
  if (/\bapi attive\b|\bapi\b|\bendpoints\b/.test(text)) {
    return apiActiveResponses[0];
  }
  if (/\bteam progetto\b|\bteam\b|\bprogetto\b/.test(text)) {
    return teamProjectResponses[0];
  }

  return "Al momento non sono capace di aiutarti su questo, ma sto continuando a imparare.";
}

  function performSend(msg) {
    const trimmed = String(msg).trim();
    if (trimmed === "") return;
    appendMessage(trimmed, "Utente");
    input.value = "";
    sendBtn.disabled = true;
    input.focus();

    // Handle conflict resolution
    if (window.chatContext && window.chatContext.awaitingConflictResolution) {
      const time = parseTime(trimmed);
      
      if (time) {
        // Check if new time also conflicts (pass the day)
        const conflict = checkRoutineConflict(time, window.chatContext.pendingEventName, window.chatContext.pendingDay);
        if (conflict) {
          const alternatives = suggestAlternativeTime(time);
          appendMessage(formatConflictMessage(conflict, window.chatContext.pendingEventName, alternatives), "AI");
          window.chatContext.conflictTime = time;
          return;
        }
        
        // No conflict, add event
        const ok = addCalendarEvent(
          window.chatContext.pendingEventName,
          window.chatContext.pendingDay,
          time
        );
        if (ok) {
          appendMessage(`‚úÖ Evento aggiunto: ${window.chatContext.pendingEventName} ‚Äî ${DAY_DISPLAY[window.chatContext.pendingDay]} alle ${time}`, "AI");
        } else {
          appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
        }
        
        // Reset all flags
        window.chatContext.awaitingConflictResolution = false;
        window.chatContext.awaitingTimeConfirmation = false;
        window.chatContext.awaitingDayConfirmation = false;
        window.chatContext.pendingEventName = null;
        window.chatContext.pendingDay = null;
        window.chatContext.conflictTime = null;
        return;
      } else {
        appendMessage("Non ho capito l'orario. Puoi riprovare? (es. 19:30)", "AI");
        return;
      }
    }

    // Handle time confirmation after day selection
    if (window.chatContext && window.chatContext.awaitingTimeConfirmation) {
      // Check if user wants to skip
      if (/\b(salta|skip|no|nessun|senza)\b/.test(trimmed.toLowerCase())) {
        if (window.chatContext.pendingEventName && window.chatContext.pendingDay) {
          const ok = addCalendarEvent(
            window.chatContext.pendingEventName, 
            window.chatContext.pendingDay,
            null
          );
          if (ok) {
            appendMessage(`Evento aggiunto: ${window.chatContext.pendingEventName} ‚Äî ${DAY_DISPLAY[window.chatContext.pendingDay]}`, "AI");
          } else {
            appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
          }
          // Reset all flags
          window.chatContext.awaitingTimeConfirmation = false;
          window.chatContext.awaitingDayConfirmation = false;
          window.chatContext.pendingEventName = null;
          window.chatContext.pendingDay = null;
          return;
        }
      }

      const time = parseTime(trimmed);
      
      if (time && window.chatContext.pendingEventName && window.chatContext.pendingDay) {
        // Check for routine conflict with event name and day
        const conflict = checkRoutineConflict(time, window.chatContext.pendingEventName, window.chatContext.pendingDay);
        if (conflict) {
          const alternatives = suggestAlternativeTime(time);
          window.chatContext.awaitingTimeConfirmation = false;
          window.chatContext.awaitingConflictResolution = true;
          window.chatContext.conflictTime = time;
          appendMessage(formatConflictMessage(conflict, window.chatContext.pendingEventName, alternatives), "AI");
          return;
        }

        const ok = addCalendarEvent(
          window.chatContext.pendingEventName, 
          window.chatContext.pendingDay,
          time
        );
        if (ok) {
          appendMessage(`‚úÖ Evento aggiunto: ${window.chatContext.pendingEventName} ‚Äî ${DAY_DISPLAY[window.chatContext.pendingDay]} alle ${time}`, "AI");
        } else {
          appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
        }
        // Reset all flags
        window.chatContext.awaitingTimeConfirmation = false;
        window.chatContext.awaitingDayConfirmation = false;
        window.chatContext.pendingEventName = null;
        window.chatContext.pendingDay = null;
        return;
      } else {
        appendMessage("Non ho capito l'orario. Puoi scriverlo in formato HH:MM (es. 14:30) o scrivere 'salta' per non specificarlo.", "AI");
        return;
      }
    }

    // Handle day confirmation after suggestion
    if (window.chatContext && window.chatContext.awaitingDayConfirmation) {
      const details = parseEventDetails(trimmed);
      const day = details ? details.day : null;
      
      if (day && window.chatContext.pendingEventName) {
        // Check if time was provided
        if (details && details.time) {
          // Check for routine conflict with event name and day
          const conflict = checkRoutineConflict(details.time, window.chatContext.pendingEventName, day);
          if (conflict) {
            const alternatives = suggestAlternativeTime(details.time);
            window.chatContext.awaitingDayConfirmation = false;
            window.chatContext.awaitingConflictResolution = true;
            window.chatContext.pendingDay = day;
            window.chatContext.conflictTime = details.time;
            appendMessage(formatConflictMessage(conflict, window.chatContext.pendingEventName, alternatives), "AI");
            return;
          }

          const ok = addCalendarEvent(window.chatContext.pendingEventName, day, details.time);
          if (ok) {
            appendMessage(`‚úÖ Evento aggiunto: ${window.chatContext.pendingEventName} ‚Äî ${DAY_DISPLAY[day]} alle ${details.time}`, "AI");
          } else {
            appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
          }
          // Reset all flags
          window.chatContext.awaitingDayConfirmation = false;
          window.chatContext.awaitingTimeConfirmation = false;
          window.chatContext.pendingEventName = null;
          window.chatContext.pendingDay = null;
        } else {
          // Ask for time
          window.chatContext.awaitingDayConfirmation = false;
          window.chatContext.awaitingTimeConfirmation = true;
          window.chatContext.pendingDay = day;
          appendMessage(`Perfetto, ${DAY_DISPLAY[day]}. A che ora? (es. 14:30 o scrivi 'salta' per non specificarlo)`, "AI");
        }
        return;
      } else {
        appendMessage("Non ho capito il giorno. Puoi ripetere? (es. luned√¨, marted√¨...)", "AI");
        return;
      }
    }

    // If we are awaiting event details, try to parse or request missing pieces
    if (window.chatContext && window.chatContext.awaitingEvent) {
      // Check if user wants to skip time
      if (/\b(salta|skip|no|nessun|senza)\b/.test(trimmed.toLowerCase())) {
        if (window.chatContext.pendingDay && window.chatContext.pendingName) {
          const ok = addCalendarEvent(window.chatContext.pendingName, window.chatContext.pendingDay, null);
          if (ok) {
            appendMessage(`Evento aggiunto: ${window.chatContext.pendingName} ‚Äî ${DAY_DISPLAY[window.chatContext.pendingDay]}`, "AI");
          } else {
            appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
          }
          // Reset all flags
          window.chatContext.awaitingEvent = false;
          window.chatContext.pendingDay = null;
          window.chatContext.pendingName = null;
          return;
        }
      }

      // If previously we stored day and name, now waiting for time
      if (window.chatContext.pendingDay && window.chatContext.pendingName) {
        const time = parseTime(trimmed);
        const day = window.chatContext.pendingDay;
        const name = window.chatContext.pendingName;
        
        // Check for routine conflict with event name and day
        if (time) {
          const conflict = checkRoutineConflict(time, name, day);
          if (conflict) {
            const alternatives = suggestAlternativeTime(time);
            window.chatContext.awaitingEvent = false;
            window.chatContext.awaitingConflictResolution = true;
            window.chatContext.conflictTime = time;
            appendMessage(formatConflictMessage(conflict, name, alternatives), "AI");
            return;
          }
        }

        const ok = addCalendarEvent(name, day, time);
        if (ok) {
          const timeStr = time ? ` alle ${time}` : '';
          appendMessage(`‚úÖ Evento aggiunto: ${name} ‚Äî ${DAY_DISPLAY[day]}${timeStr}`, "AI");
        } else {
          appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
        }
        // Reset all flags
        window.chatContext.awaitingEvent = false;
        window.chatContext.pendingDay = null;
        window.chatContext.pendingName = null;
        return;
      }

      // If previously we stored only day and asked for name
      if (window.chatContext.pendingDay) {
        let name = cleanEventName(trimmed);
        name = name.charAt(0).toUpperCase() + name.slice(1);
        const day = window.chatContext.pendingDay;
        
        // Ask for time
        window.chatContext.pendingName = name;
        appendMessage(`A che ora √® "${name}"? (es. 14:30 o scrivi 'salta' per non specificarlo)`, "AI");
        return;
      }

      const details = parseEventDetails(trimmed);
      if (!details) {
        appendMessage("Non ho capito. Dimmi il nome dell'evento, il giorno e l'orario (es. 'Cena di lavoro luned√¨ alle 19:30')", "AI");
        return;
      }

      if (!details.name) {
        // We found a day but not a name: ask for the name and save day
        window.chatContext.pendingDay = details.day;
        appendMessage("Mi serve il nome dell'evento. Come si chiama?", "AI");
        return;
      }

      // Have name and day, check if we have time
      if (details.time) {
        // Check for routine conflict with event name and day
        const conflict = checkRoutineConflict(details.time, details.name, details.day);
        if (conflict) {
          const alternatives = suggestAlternativeTime(details.time);
          window.chatContext.awaitingEvent = false;
          window.chatContext.awaitingConflictResolution = true;
          window.chatContext.pendingDay = details.day;
          window.chatContext.pendingName = details.name;
          window.chatContext.conflictTime = details.time;
          appendMessage(formatConflictMessage(conflict, details.name, alternatives), "AI");
          return;
        }

        // Have everything -> add event
        const ok = addCalendarEvent(details.name, details.day, details.time);
        if (ok) {
          appendMessage(`‚úÖ Evento aggiunto: ${details.name} ‚Äî ${DAY_DISPLAY[details.day]} alle ${details.time}`, "AI");
        } else {
          appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
        }
        // Reset all flags
        window.chatContext.awaitingEvent = false;
        window.chatContext.pendingDay = null;
        window.chatContext.pendingName = null;
      } else {
        // Ask for time
        window.chatContext.pendingDay = details.day;
        window.chatContext.pendingName = details.name;
        appendMessage(`A che ora √® "${details.name}"? (es. 14:30 o scrivi 'salta' per non specificarlo)`, "AI");
      }
      return;
    }

    // NEW: Check if user wants suggestions first (before direct add)
    const normalized = trimmed.normalize ? trimmed.normalize('NFD').replace(/\p{Diacritic}/gu, '') : trimmed;
    const lowerText = normalized.toLowerCase();
    
    // Check for "vorrei" pattern - user wants suggestions
    if (/\b(vorrei|dovrei|potrei|quando posso|quando potrei)\b/.test(lowerText)) {
      // Try to extract event name
      const text = lowerText.replace(/\b(vorrei|dovrei|potrei|quando posso|quando potrei|aggiungere|inserire|mettere|programmare|un|una|uno)\b/g, '').trim();
      
      // Try to parse to get clean event name
      let eventName = null;
      const tempDetails = parseEventDetails(trimmed);
      if (tempDetails && tempDetails.name) {
        eventName = tempDetails.name;
      } else if (text.length > 0) {
        eventName = cleanEventName(text);
        eventName = eventName.charAt(0).toUpperCase() + eventName.slice(1);
      }
      
      const availability = suggestAvailableDays();
      const suggestions = formatDaySuggestions(availability);
      
      if (eventName) {
        window.chatContext.awaitingDayConfirmation = true;
        window.chatContext.pendingEventName = eventName;
        appendMessage(`Per "${eventName}" ti suggerisco: ${suggestions}. Quale giorno preferisci?`, "AI");
        return;
      } else {
        appendMessage(`I giorni migliori sono: ${suggestions}. Dimmi quale evento vuoi aggiungere e in che giorno.`, "AI");
        return;
      }
    }
    
    // Check if user wants to add event directly
    if (/\b(aggiungi|aggiung|aggiungere|voglio aggiungere|inserisci|metti|crea evento)\b/.test(lowerText)) {
      // Try to parse full details immediately
      const details = parseEventDetails(trimmed);
      
      if (details && details.name && details.day) {
        // Have name and day
        if (details.time) {
          // Check for routine conflict with event name and day
          const conflict = checkRoutineConflict(details.time, details.name, details.day);
          if (conflict) {
            const alternatives = suggestAlternativeTime(details.time);
            window.chatContext.awaitingConflictResolution = true;
            window.chatContext.pendingDay = details.day;
            window.chatContext.pendingEventName = details.name;
            window.chatContext.conflictTime = details.time;
            appendMessage(formatConflictMessage(conflict, details.name, alternatives), "AI");
            return;
          }
          
          // No conflict, add directly
          const ok = addCalendarEvent(details.name, details.day, details.time);
          if (ok) {
            appendMessage(`‚úÖ Evento aggiunto: ${details.name} ‚Äî ${DAY_DISPLAY[details.day]} alle ${details.time}`, "AI");
          } else {
            appendMessage("Errore durante l'aggiunta dell'evento.", "AI");
          }
          return;
        } else {
          // Ask for time
          window.chatContext.awaitingEvent = true;
          window.chatContext.pendingDay = details.day;
          window.chatContext.pendingName = details.name;
          appendMessage(`A che ora √® "${details.name}"? (es. 14:30 o scrivi 'salta' per non specificarlo)`, "AI");
          return;
        }
      } else {
        // Not enough info, start the guided flow
        window.chatContext.awaitingEvent = true;
        appendMessage("Perfetto, dimmi il nome dell'evento e il giorno (puoi includere anche l'orario)", "AI");
        return;
      }
    }

    // Default behaviour: get an AI suggestion/response
    const aiResp = aiSuggestion(trimmed);
    appendMessage(aiResp, "AI");
  }

  sendBtn.addEventListener("click", () => { performSend(input.value); });
  input.addEventListener("keypress", e => {
    if (e.key === "Enter" && canSend()) {
      e.preventDefault();
      performSend(input.value);
    }
  });
  suggestions.querySelectorAll("button").forEach(b => {
    b.addEventListener("click", () => { performSend(b.dataset.msg); });
  });
}
setupChat("messages", "userInput", "sendBtn", "suggestions");
setupChat("messagesDev", "devInput", "devSendBtn", "suggestionsDev");
const integrationList = document.getElementById('integrationList');
const addIntegrationBtn = document.getElementById('addIntegrationBtn');
let integrations = [
  {name: "Google Calendar", active: true},
  {name: "WhatsApp", active: false},
];
function renderIntegrations() {
  integrationList.innerHTML = '';
  integrations.forEach((service, i) => {
    const li = document.createElement('li');
    li.className = 'integration-item';
    li.setAttribute('tabindex', 0);
    li.setAttribute('role', 'button');
    li.setAttribute('aria-pressed', service.active ? 'true' : 'false');
    li.textContent = service.name;
    const status = document.createElement('span');
    status.className = 'integration-status';
    status.textContent = service.active ? '‚úÖ' : '‚öôÔ∏è';
    li.appendChild(status);
    li.addEventListener('click', () => {
      integrations[i].active = !integrations[i].active;
      renderIntegrations();
    });
    li.addEventListener('keyup', e => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        li.click();
      }
    });
    integrationList.appendChild(li);
  });
}
renderIntegrations();
renderCalendar();
  addIntegrationBtn.addEventListener('click', () => {
    const newName = prompt("Inserisci nome del nuovo servizio:");
    if(newName && newName.trim() !== "") {
      integrations.push({name: newName.trim(), active: true});
      renderIntegrations();
    }
  });
</script>
</body>
</html>
